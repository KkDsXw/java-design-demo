动态代理分： JDK动态代理，CGLIB动态代理
JDK动态代理
    1.拿到被代理对象的引用，获取它的所有的接口，反射获取
    2.JDK Proxy类重新生成一个新的类，同时新生成的类需要实现被代理类的所有接口
    3.结合自定义的业务代码动态生成java代码(在代码中体现) ---->$Proxy0.java
    4.编译新生成的java代码.class ---->$Proxy0.class
    5.再重新加载到jvm中运行
    ==> 以上过程叫做字节码重组


CGLIB动态代理
    cglib不是通过反射完成的，而是直接对方法进行调用，通过运行时动态生成一个被代理类的子类，
    在子类方法中直接调用super中的方法完成代理，它的底层通过FastClass对Class对象的method的引用保存在数组中，
    通过数组索引直接进行方法调用；不用实现接口；

两者对比
    1.性能上，JDK动态代理碾压CGLIB动态代理

     执行次数   jdk(毫秒)    cglib(毫秒)     性能相差(倍)
     10        10           130             13
     1000      51           187             3.7
     1W        220          438             1.99
     10w       1508         2229            1.47
     100w      13324        14969           1.12
